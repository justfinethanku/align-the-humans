# App Library (`/app/lib`)

This directory contains core TypeScript types, Supabase client configurations, and database helper functions for the Human Alignment application.

## Files Overview

### `types.ts`
Comprehensive TypeScript types for all database tables and JSONB structures:
- **Enums**: `AlignmentStatus`, `UIStatus`, `QuestionType`, `ConflictSeverity`, `ParticipantRole`
- **Table Types**: `Profile`, `Partner`, `Alignment`, `AlignmentParticipant`, `Template`, `AlignmentResponse`, `AlignmentAnalysis`, `AlignmentSignature`
- **JSONB Types**: `TemplateContent`, `ResponseAnswers`, `AnalysisSummary`, `CanonicalSnapshot`
- **Type Guards**: `isAlignmentStatus()`, `isProfile()`, `isAlignment()`, etc.
- **Utility Types**: `AlignmentCreate`, `AlignmentUpdate`, `AlignmentDetail`, `QueryResult`, `PaginatedResult`
- **State Machine**: `VALID_STATUS_TRANSITIONS`, `isValidStatusTransition()`, `getNextValidStatuses()`

### `database.types.ts`
Auto-generated Supabase database types. Maps PostgreSQL schema to TypeScript types for type-safe queries.

**Note:** This file is generated by `supabase gen types typescript` command. Do not edit manually.

### `supabase-browser.ts`
Supabase client for browser/client-side usage:
- Uses `createBrowserClient` from `@supabase/ssr`
- Suitable for Client Components (`'use client'`)
- Handles realtime subscriptions
- Auto-manages auth state in browser

**Usage:**
```tsx
'use client';

import { createClient } from '@/app/lib/supabase-browser';

export function MyComponent() {
  const supabase = createClient();

  const loadData = async () => {
    const { data } = await supabase.from('profiles').select('*');
    return data;
  };
}
```

### `supabase-server.ts`
Supabase clients for server-side usage:
- **`createServerClient()`** - Standard server client with RLS enforcement
- **`createAdminClient()`** - Admin client with service role key (bypasses RLS)
- **`getCurrentUser()`** - Get authenticated user from session
- **`getCurrentSession()`** - Get current session
- **`requireAuth()`** - Require authentication or throw error

**Usage in Server Components:**
```tsx
import { createServerClient, requireAuth } from '@/app/lib/supabase-server';

export default async function MyPage() {
  const supabase = createServerClient();
  const user = await requireAuth(supabase);

  const { data } = await supabase.from('profiles').select('*');
  return <div>{data?.display_name}</div>;
}
```

**Usage in Route Handlers:**
```tsx
import { createServerClient } from '@/app/lib/supabase-server';

export async function GET(request: Request) {
  const supabase = createServerClient();
  const { data, error } = await supabase.from('alignments').select('*');

  if (error) {
    return Response.json({ error: error.message }, { status: 500 });
  }

  return Response.json({ data });
}
```

### `db-helpers.ts`
Type-safe helper functions for common database operations:

**Profile Operations:**
- `getProfile(supabase, userId)` - Get user profile
- `upsertProfile(supabase, userId, displayName)` - Create/update profile

**Alignment Operations:**
- `getUserAlignments(supabase, userId)` - Get all user's alignments
- `getAlignmentDetail(supabase, alignmentId, userId)` - Get full alignment details
- `createAlignment(supabase, data)` - Create new alignment
- `updateAlignmentStatus(supabase, alignmentId, status)` - Update status

**Participant Operations:**
- `addParticipant(supabase, data)` - Add participant to alignment
- `isParticipant(supabase, alignmentId, userId)` - Check participation

**Response Operations:**
- `saveResponse(supabase, data)` - Save/update user response
- `submitResponse(supabase, alignmentId, userId, round)` - Mark response as submitted
- `getRoundResponses(supabase, alignmentId, round)` - Get both participants' responses

**Analysis Operations:**
- `saveAnalysis(supabase, data)` - Save AI analysis
- `getAnalysis(supabase, alignmentId, round)` - Get analysis for round

**Template Operations:**
- `getTemplates(supabase)` - Get all templates
- `getTemplate(supabase, templateId)` - Get specific template

**Signature Operations:**
- `createSignature(supabase, data)` - Create digital signature
- `getSignatures(supabase, alignmentId)` - Get all signatures for alignment

**Example:**
```tsx
import { createServerClient, getUserAlignments } from '@/app/lib';

export default async function Dashboard() {
  const supabase = createServerClient();
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) return <div>Not authenticated</div>;

  const { data: alignments, error } = await getUserAlignments(supabase, user.id);

  return (
    <div>
      {alignments?.map(alignment => (
        <div key={alignment.id}>{alignment.title}</div>
      ))}
    </div>
  );
}
```

### `index.ts`
Barrel export file for convenient imports. Import everything from `@/app/lib` instead of individual files.

**Example:**
```tsx
// Instead of:
import { createServerClient } from '@/app/lib/supabase-server';
import { getProfile } from '@/app/lib/db-helpers';
import { isAlignmentStatus } from '@/app/lib/types';

// Use:
import { createServerClient, getProfile, isAlignmentStatus } from '@/app/lib';
```

## Environment Variables

Required in `.env.local`:

```bash
# Public (exposed to browser)
NEXT_PUBLIC_SUPABASE_URL=your_supabase_url
NEXT_PUBLIC_SUPABASE_ANON_KEY=your_anon_key

# Server-only (never exposed to client)
SUPABASE_SERVICE_ROLE_KEY=your_service_role_key
```

## Type Safety Best Practices

1. **Always use type guards** when validating user input or API data:
   ```tsx
   if (isAlignmentStatus(status)) {
     await updateAlignmentStatus(supabase, id, status);
   }
   ```

2. **Use QueryResult wrapper** for consistent error handling:
   ```tsx
   const { data, error } = await getProfile(supabase, userId);
   if (error) {
     console.error('Failed to load profile:', error);
     return null;
   }
   ```

3. **Validate state transitions** before updating alignment status:
   ```tsx
   import { isValidStatusTransition, getNextValidStatuses } from '@/app/lib';

   if (isValidStatusTransition(currentStatus, newStatus)) {
     await updateAlignmentStatus(supabase, alignmentId, newStatus);
   } else {
     const validNext = getNextValidStatuses(currentStatus);
     throw new Error(`Invalid transition. Valid: ${validNext.join(', ')}`);
   }
   ```

4. **Use utility types** for create/update operations:
   ```tsx
   import type { AlignmentCreate, AlignmentUpdate } from '@/app/lib';

   const newAlignment: AlignmentCreate = {
     partner_id: partnerId,
     title: 'New Alignment',
     status: 'draft',
     created_by: userId,
   };

   const updates: AlignmentUpdate = {
     status: 'active',
     title: 'Updated Title',
   };
   ```

## Realtime Subscriptions

For realtime features, use browser client:

```tsx
'use client';

import { createClient } from '@/app/lib/supabase-browser';
import { useEffect } from 'react';

export function RealtimeAlignmentUpdates({ alignmentId }: { alignmentId: string }) {
  const supabase = createClient();

  useEffect(() => {
    const channel = supabase
      .channel(`alignment:${alignmentId}:responses`)
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'alignment_responses',
          filter: `alignment_id=eq.${alignmentId}`,
        },
        (payload) => {
          console.log('Response updated:', payload);
        }
      )
      .subscribe();

    return () => {
      supabase.removeChannel(channel);
    };
  }, [alignmentId, supabase]);

  return <div>Listening for updates...</div>;
}
```

## State Machine Validation

Alignment status follows strict state machine:

```
draft → active → analyzing → resolving → complete
```

Use validation helpers:

```tsx
import { VALID_STATUS_TRANSITIONS, isValidStatusTransition } from '@/app/lib';

// Check if transition is valid
if (isValidStatusTransition('draft', 'active')) {
  // ✅ Valid: draft → active
}

if (isValidStatusTransition('draft', 'analyzing')) {
  // ❌ Invalid: can't skip from draft to analyzing
}

// Get valid next statuses
const nextStatuses = getNextValidStatuses('draft');
// Returns: ['active']
```

## Security Considerations

1. **RLS Policies**: All tables have Row-Level Security enabled. Standard clients enforce RLS.
2. **Service Role Key**: Only use `createAdminClient()` in secure server contexts. Never expose to client.
3. **Participant Validation**: Always verify user is participant before showing sensitive data.
4. **Response Privacy**: Partner responses are hidden until both submit for the round (enforced by RLS).

## Regenerating Database Types

When database schema changes, regenerate types:

```bash
npx supabase gen types typescript --project-id qvzfcezbuzmvglgiolmh > app/lib/database.types.ts
```

Or use local database:

```bash
npx supabase gen types typescript --local > app/lib/database.types.ts
```

## Testing

Test type safety during development:

```bash
npm run type-check
```

This runs `tsc --noEmit` to verify all TypeScript types compile without errors.
